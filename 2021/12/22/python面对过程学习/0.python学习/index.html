
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>0.python学习 - fubaisen</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="学习方法\1. 每天知识点必须理解（定义、作用、适用性、语法）
\2. 每天练习必须会做（独立完成）
\3. 将理论、代码、图示形成笔记保留下来（合三为一）
\4. 课上注意听！课下抓紧练、不懂马上,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="fubaisen" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="0.python学习 - fubaisen"/>
    <meta name="twitter:description" content="学习方法\1. 每天知识点必须理解（定义、作用、适用性、语法）
\2. 每天练习必须会做（独立完成）
\3. 将理论、代码、图示形成笔记保留下来（合三为一）
\4. 课上注意听！课下抓紧练、不懂马上,"/>
    
    
    
    
    <meta property="og:site_name" content="fubaisen"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="0.python学习 - fubaisen"/>
    <meta property="og:description" content="学习方法\1. 每天知识点必须理解（定义、作用、适用性、语法）
\2. 每天练习必须会做（独立完成）
\3. 将理论、代码、图示形成笔记保留下来（合三为一）
\4. 课上注意听！课下抓紧练、不懂马上,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">fubaisen</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://fubaisen.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">0.python学习</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">0.python学习</h1>
        <div class="stuff">
            <span>十二月 22, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/python%E5%AD%A6%E4%B9%A0/" rel="tag">python学习</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h1><p>\1. 每天知识点必须理解（定义、作用、适用性、语法）</p>
<p>\2. 每天练习必须会做（独立完成）</p>
<p>\3. 将理论、代码、图示形成笔记保留下来（合三为一）</p>
<p>\4. 课上注意听！课下抓紧练、不懂马上问（群讨论）</p>
<h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps8594.tmp.png" alt="img"></h1><h1 id="Python-简介"><a href="#Python-简介" class="headerlink" title="*Python* *简介*"></a><em><strong>*Python*</strong></em> <em><strong>*简介*</strong></em></h1><p>程序员：</p>
<p>程序设计人员。</p>
<p>程序：</p>
<p>一组由计算机负责执行的指令，是实现某种需求的软件。 </p>
<p>操作系统：</p>
<p>管理和控制计算机硬件与软件资源的程序，隔离不同硬件的差异，使开发程序简单化。</p>
<p>例如，Windows，Linux，Unix。</p>
<p>硬件：</p>
<p>主板–计算机的主要电路系统。</p>
<p>CPU –主要负责执行程序指令，处理数据。</p>
<p>硬盘–持久化存储数据的记忆设备，容量大，速度慢。</p>
<p>内存–临时存储数据的记忆设备，容量小，速度快。</p>
<p>IO设备–键盘、鼠标、显示器。</p>
<h2 id="Python-定义"><a href="#Python-定义" class="headerlink" title="*Python* *定义*"></a><em><strong>*Python*</strong></em> <em><strong>*定义*</strong></em></h2><p><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps8595.tmp.jpg" alt="img"> </p>
<p>是一个免费、开源、跨平台、动态、面向对象的编程语言。</p>
<h2 id="Python程序的执行方式"><a href="#Python程序的执行方式" class="headerlink" title="*Python程序的执行方式*"></a><em><strong>*Python程序的执行方式*</strong></em></h2><h3 id="交互式"><a href="#交互式" class="headerlink" title="*交互式*"></a><em><strong>*交互式*</strong></em></h3><p>在命令行输入指令，回车即可得到结果。</p>
<p>\1. 打开终端</p>
<p>\2. 进入：python3</p>
<p>\3. python代码：print(“hello world”) </p>
<p>\4. 离开：exit()</p>
<h3 id="文件式"><a href="#文件式" class="headerlink" title="*文件式*"></a><em><strong>*文件式*</strong></em></h3><p>将指令编写到.py文件，可以重复运行程序。</p>
<p>\1. 在指定目录中创建Python文件</p>
<p>目录：&#x2F;home&#x2F;tarena&#x2F;month01&#x2F;python_base&#x2F;day01</p>
<p>文件名:hello.py</p>
<p>\2. 在终端命令行输入如下命令: </p>
<p>  cd &#x2F;home&#x2F;tarena&#x2F;month01&#x2F;python_base&#x2F;day01</p>
<p>python3 hello.py</p>
<h2 id="Linux-常用-命令"><a href="#Linux-常用-命令" class="headerlink" title="*Linux**常用**命令*"></a><em><strong>*Linux*</strong></em><em><strong>*常用*</strong></em><em><strong>*命令*</strong></em></h2><p>(1) pwd：查看当前工作目录的路径 </p>
<p>(2) ls：查看指定目录的内容或文件信息   </p>
<p>(3) cd命令:改变工作目录（进入到某个目录）       </p>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="*执行过程*"></a><em><strong>*执行过程*</strong></em></h2><p><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85A6.tmp.jpg" alt="img"> </p>
<p>计算机只能识别机器码(1010)，不能识别源代码(python)。</p>
<p>由源代码转变成机器码的过程分成两类：编译和解释。</p>
<p>编译：在程序执行之前，通过编译器将源代码变成机器码；</p>
<p>运行时，计算机就可以直接执行。例如：C语言。</p>
<p>优点是运行速度快；缺点是开发效率低，不能跨平台。</p>
<p>解释：运行时，通过解释器对程序逐行解释，然后运行。例如Javascript</p>
<p>   优点是开发效率高，可以跨平台；缺点是运行速度低。</p>
<p>python是解释型语言，但出于效率的考虑，提供了一种编译的方法。编译之后就得到pyc文件，存储了字节码（特定于Python的表现形式，不是机器码）。</p>
<p>​	python执行过程：</p>
<p>​	源代码 –编译–&gt; 字节码–解释–&gt; 机器码</p>
<p>​	|————1次————|</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85A7.tmp.png" alt="img"></h2><h2 id="解释器类型"><a href="#解释器类型" class="headerlink" title="*解释器类型*"></a><em><strong>*解释器类型*</strong></em></h2><p>CPython（C语言开发)</p>
<p>Jython (java开发)</p>
<p>IronPython (.net开发)</p>
<h1 id="数据基本运算"><a href="#数据基本运算" class="headerlink" title="*数据基本运算*"></a><em><strong>*数据基本运算*</strong></em></h1><h2 id="py-charm-常用快捷键"><a href="#py-charm-常用快捷键" class="headerlink" title="*py**charm**常用快捷键*"></a><em><strong>*py*</strong></em><em><strong>*charm*</strong></em><em><strong>*常用快捷键*</strong></em></h2><p>移动到本行开头：home键</p>
<p>移动到本行末尾：end键盘</p>
<p>注释代码：ctrl + &#x2F;</p>
<p>复制行：ctrl +d</p>
<p>选择列：鼠标左键 + alt</p>
<p>移动行：shift + alt + 上下箭头</p>
<p>智能提示：Ctrl + Space</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="*注释*"></a><em><strong>*注释*</strong></em></h2><p>给人看的，通常是对代码的描述信息。</p>
<p>\1. 单行注释：以#号开头。</p>
<p>\2. 多行注释：三引号开头，三引号结尾。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="*函数*"></a><em><strong>*函数*</strong></em></h2><p>表示一个功能，函数定义者是提供功能的人，函数调用者是使用功能的人。</p>
<p>例如：</p>
<p>print(数据) 作用：将括号中的内容显示在控制台中</p>
<p>变量 &#x3D; input(“需要显示的内容”) 作用：将用户输入的内容赋值给变量</p>
<p><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85A8.tmp.png" alt="img"> </p>
<p>代码：函数</p>
<p>Print（“需要显示的内容”）：</p>
<p>Qxt  &#x3D; input（“需要显示的内容”）</p>
<p>Print（qxt） </p>
<h2 id="变量"><a href="#变量" class="headerlink" title="*变量*"></a><em><strong>*变量*</strong></em></h2><p>定义：关联一个对象的标识符。</p>
<p>  命名：必须是字母或下划线开头，后跟字母、数字、下划线。</p>
<p>​     不能使用python的关键字(蓝色)，否则发生语法错误：SyntaxError: invalid syntax。</p>
<p>建议命名：字母小写，多个单词以下划线隔开。</p>
<p>​     class_name</p>
<p>赋值：创建一个变量或改变一个变量绑定的数据。</p>
<p>  语法：变量名 &#x3D; 数据</p>
<p>​     变量名1 &#x3D; 变量名2 &#x3D; 数据</p>
<p>​     变量名1, 变量名2, &#x3D; 数据1, 数据2</p>
<p><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85A9.tmp.png" alt="img"><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85AA.tmp.png" alt="img"> </p>
<p>代码：变量</p>
<p>变量名&#x3D;….</p>
<p>a &#x3D; “你好” </p>
<p>b &#x3D; “世界”</p>
<p>c &#x3D; b + a</p>
<p>class_name &#x3D; “1903”</p>
<p>stu_name &#x3D; “zs”</p>
<p>class_name &#x3D; class_name + stu_name<img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85BB.tmp.png" alt="img"></p>
<h2 id="del-语句"><a href="#del-语句" class="headerlink" title="*del 语句*"></a><em><strong>*del 语句*</strong></em></h2><p>语法: del 变量名1, 变量名2</p>
<p>作用：用于删除变量,同时解除与对象的关联关系.如果可能则释放对象。</p>
<p>自动化内存管理的引用计数：每个对象记录被变量绑定(引用)的数量,当为0时被销毁。</p>
<h2 id="核心数据类-型"><a href="#核心数据类-型" class="headerlink" title="核心数据类*型*"></a>核心数据类<em><strong>*型*</strong></em></h2><p>在python中变量没有类型，但关联的对象有类型。</p>
<p>通过type函数可查看。</p>
<h3 id="空值对象-None"><a href="#空值对象-None" class="headerlink" title="*空值对象* *None*"></a><em><strong>*空值对象*</strong></em> <em><strong>*None*</strong></em></h3><pre><code> 表示不存在的特殊对象
</code></pre>
<p>作用:</p>
<pre><code>      用来占位
  
  变量解除绑定
</code></pre>
<h3 id="整形i-nt"><a href="#整形i-nt" class="headerlink" title="*整形i**nt*"></a><em><strong>*整形i*</strong></em><em><strong>*nt*</strong></em></h3><p>整数，包含正数、负数、0。</p>
<p>   - 如： -5, 100, 0</p>
<p>字面值：</p>
<p>– 十进制：5 </p>
<p>num01 &#x3D; 18</p>
<p>– 二进制：0b101</p>
<p>– 二进制(每逢2进1)  0  1   10  11  100  101   110  ….</p>
<p>num02 &#x3D; 0b11</p>
<p>print(num02)</p>
<p>– 八进制方式表示(0o开头，后跟0~7)</p>
<p>– 八进制(每逢8进1) 0 1 … 7  10  11  12  …</p>
<p>num03 &#x3D; 0o10</p>
<p>print(num03)</p>
<p>– 十六进制表示(0x开头后跟0<del>9,A</del>F,a~f)</p>
<p>– 十六进制(每逢16进1) 0–9   a(10) – f(15)</p>
<p>num04 &#x3D; 0x10</p>
<p>print(num04)</p>
<p>小整数对象池：CPython 中整数 -5 至 256,永远存在小整数对象池中,不会被释放并可重复使用。</p>
<p>小整数对象池</p>
<p>a &#x3D; 500</p>
<p>b &#x3D; 500</p>
<p># id函数:返回变量存储的对象地址</p>
<p>print(id(a))</p>
<p>print(id(b)) <img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85BC.tmp.png" alt="img"></p>
<p># 备注:在交互式中,两个500不是同一个对象. </p>
<h3 id="浮点型f-loat"><a href="#浮点型f-loat" class="headerlink" title="*浮点型f**loat*"></a><em><strong>*浮点型f*</strong></em><em><strong>*loat*</strong></em></h3><p>小数(包含正数、负数，0.0) </p>
<p>字面值：</p>
<p>– 小数：1.0  2.5</p>
<p>浮点数(小数)float</p>
<p>f01 &#x3D; 1.0</p>
<p>– 科学计数法：e&#x2F;E (正负号) 指数 </p>
<p>​    1.23e-2 (等同于0.0123)</p>
<p>​    1.23456e5(等同于123456.0)</p>
<p>f03 &#x3D; 1.234e-3</p>
<p>print(f03)</p>
<h3 id="字符串str"><a href="#字符串str" class="headerlink" title="*字符串str*"></a><em><strong>*字符串str*</strong></em></h3><p>​	是用来记录文本信息(文字信息)。</p>
<p>​	字面值：双引号</p>
<p>字符串str</p>
<p>s01 &#x3D; “唐僧”</p>
<p>s02 &#x3D; “10”</p>
<p>s03 &#x3D; “1.5”</p>
<p>print(“10”+”2”)</p>
<p>print(10+2)</p>
<h3 id="复数-complex"><a href="#复数-complex" class="headerlink" title="*复数**complex*"></a><em><strong>*复数*</strong></em><em><strong>*complex*</strong></em></h3><p>由实部和虚部组成的数字。</p>
<p>虚部是以j或J结尾。</p>
<p>字面值： 1j   1+1j  1-1j </p>
<p>c01 &#x3D; 1j</p>
<p>c02 &#x3D; 5 + 1j</p>
<p>print(c02)</p>
<p>print(type(c01))</p>
<h3 id="布尔bool"><a href="#布尔bool" class="headerlink" title="*布尔bool*"></a><em><strong>*布尔bool*</strong></em></h3><p>用来表示真和假的类型</p>
<p>True 表示真(条件满足或成立)，本质是1</p>
<p>False 表示假(条件不满足或不成立)，本质是0</p>
<p>b01 &#x3D; True # 真的  对的   成立的   满足条件的</p>
<p>b02 &#x3D; False# 假的  错的   不成立的   不满足条件的</p>
<p>b03 &#x3D; 1 &gt; 2</p>
<p>print(b03)</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="*数据类型转换*"></a><em><strong>*数据类型转换*</strong></em></h2><p>​	转换为整形: int(数据)</p>
<p>​	转换为浮点型:float(数据)</p>
<p>​	转换为字符串:str(数据)</p>
<p>​	转换为布尔:bool(数据)</p>
<p>​     – 结果为False：bool(0)  bool(0.0)  bool(None)  </p>
<p>混合类型自动升级：</p>
<p> 1 + 2.14  返回的结果是 3.14</p>
<p> 1 + 3.0  返回结果是:  4.0</p>
<p>数据类型转换</p>
<p> str_score &#x3D; input(“请输入成绩:”)</p>
<p> input 函数的结果就是str,如果需要做数学运算,必须转换成数字.</p>
<p>print(type(str_score))</p>
<p># float_score &#x3D; float(str_score)</p>
<p># print(type(float_score))</p>
<p>b04 &#x3D; bool(“False”)</p>
<p>print(b04)</p>
<p>i01 &#x3D; float(“5.1”) # 如果需要转换的类型,与目标类型不一致,则错误.</p>
<p>print(i01)</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="*运算符*"></a><em><strong>*运算符*</strong></em></h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="*算术运算符*"></a><em><strong>*算术运算符*</strong></em></h3><p> +  加法</p>
<p>num01 &#x3D; 5</p>
<p>num02 &#x3D; 2.1</p>
<p>print(num01 + num02)</p>
<p> -  减法</p>
<p> *  乘法</p>
<p> &#x2F;  除法：结果为浮点数</p>
<p> &#x2F;&#x2F; 地板除：除的结果去掉小数部分</p>
<p> %  求余</p>
<p># %作用1:判断一个数能否被另外一个数整除</p>
<p>print(num01 % 2 &#x3D;&#x3D; 0)</p>
<p># %作用2: 获取个位</p>
<p>print(67 % 10)</p>
<p> ** 幂运算</p>
<p>优先级从高到低： **</p>
<p>​     		  ()</p>
<p>​             *  &#x2F; % &#x2F;&#x2F;</p>
<p>​           +  -</p>
<h3 id="增强运算符"><a href="#增强运算符" class="headerlink" title="*增强运算符*"></a><em><strong>*增强运算符*</strong></em></h3><p>  y +&#x3D; x    等同于 y &#x3D; y + x</p>
<p>num03 &#x3D; 1</p>
<p>print(num03 + 1)</p>
<p>print(num03) # 1</p>
<p>num04 &#x3D; 800</p>
<p># 修改num04</p>
<p>num04 &#x3D; num04 + 1</p>
<p>num04 +&#x3D; 1</p>
<p>  y -&#x3D; x    等同于 y &#x3D; y - x</p>
<p>  y *&#x3D; x    等同于 y &#x3D; y * x</p>
<p>  y &#x2F;&#x3D; x    等同于 y &#x3D; y &#x2F; x</p>
<p>  y &#x2F;&#x2F;&#x3D; x   等同于 y &#x3D; y &#x2F;&#x2F; x</p>
<p>  y %&#x3D; x    等同于 y &#x3D; y % x</p>
<p>  y **&#x3D; x   等同于 y &#x3D; y ** x</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="*比较运算符*"></a><em><strong>*比较运算符*</strong></em></h3><p>  &lt;   小于</p>
<p>  &lt;&#x3D;  小于等于</p>
<p>  &gt;   大于</p>
<p>  &gt;&#x3D;  大于等于</p>
<p>  &#x3D;&#x3D;  等于</p>
<p>  !&#x3D;  不等于</p>
<p>  返回布尔类型的值</p>
<p>比较运算的数学表示方式:0 &lt;&#x3D; x &lt;&#x3D; 100</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="*逻辑运算符*"></a><em><strong>*逻辑运算符*</strong></em></h3><h4 id="与-and"><a href="#与-and" class="headerlink" title="*与**and*"></a><em><strong>*与*</strong></em><em><strong>*and*</strong></em></h4><p>  表示并且的关系，一假俱假。     </p>
<p> 示例:</p>
<p>  True and True   # True</p>
<p>  True and False  # False</p>
<p>  False and True  # False</p>
<p>False and False  # False</p>
<p># 放学了  and  完成作业了   &#x3D;两个条件都满足&#x3D;&gt;  回家了</p>
<p># print(True and True)  # True</p>
<p># print(False and False)# False</p>
<p># print(True and False)# False</p>
<p># print(False and True)# False</p>
<p>#</p>
<p># print(1 &gt; 2 and 5 &gt; 3)# False</p>
<p># print(1 &lt; 2 and 5 &gt; 3 and 10 &gt; 5) # True</p>
<h4 id="或-or"><a href="#或-or" class="headerlink" title="*或**or*"></a><em><strong>*或*</strong></em><em><strong>*or*</strong></em></h4><h4 id="表示或者的-关系-，一真俱真"><a href="#表示或者的-关系-，一真俱真" class="headerlink" title="*表示或者的**关系**，一真俱真*"></a><em><strong>*表示或者的*</strong></em><em><strong>*关系*</strong></em><em><strong>*，一真俱真*</strong></em></h4><p> 示例:</p>
<p>  True or True   # True</p>
<p>  True or False   # True</p>
<p>  False or True   # True</p>
<p>False or False  # False </p>
<p># 放学了  or  完成作业了   &#x3D;满足其中一个条件即可&#x3D;&gt;  回家了</p>
<p>print(True  or True)  # True</p>
<p>print(False or False)# False</p>
<p>print(True  or  False)# True</p>
<p>print(False or True)# True</p>
<p>print(1 &gt; 2 or 5 &lt; 3 or 10 &gt; 5)  # True</p>
<p>表示取反</p>
<p>例如：</p>
<p>not True  # 返回False</p>
<p>not False  # 返回True</p>
<p>not 100   # 返回False</p>
<h4 id="短路运算"><a href="#短路运算" class="headerlink" title="*短路运算*"></a><em><strong>*短路运算*</strong></em></h4><pre><code> 一但结果确定，后面的表达式将不再执行。
</code></pre>
<p>短路逻辑</p>
<p># 如果第一个条件不满足  则不再考虑第二个条件</p>
<p># print(1 &gt; 2 and input(“请输入:”) &#x3D;&#x3D; “a”)</p>
<p># 如果第一个条件满足  则不再考虑第二个条件</p>
<p># print(1 &gt; 2 or input(“请输入:”) &#x3D;&#x3D; “a”)</p>
<p># 建议(启发):尽量将耗时的判断,放在后面.(因为很可能不执行)</p>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="*身份运算符*"></a><em><strong>*身份运算符*</strong></em></h3><p>  语法:</p>
<pre><code>      x is y
  
      x is not y
</code></pre>
<p>作用：</p>
<p>is 用于判断两个对象是否是同一个对象,是时返回True,否则返回False。</p>
<pre><code>  is not 的作用与is相反
</code></pre>
<p>num01 &#x3D; 800</p>
<p>num02 &#x3D; 9<img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85BD.tmp.png" alt="img"><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85BE.tmp.png" alt="img"></p>
<p>num03 &#x3D; num01</p>
<p>print(num01 is num02) # false</p>
<p>print(id(num01) &#x3D;&#x3D;  id(num02))</p>
<p>print(num03 is num01) #  true</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="*优先级*"></a><em><strong>*优先级*</strong></em></h3><p>​	高到低：</p>
<p>算数运算符</p>
<p>比较运算符</p>
<p>快捷运算符</p>
<p>身份运算符</p>
<p>逻辑运算符</p>
<h1 id="语句"><a href="#语句" class="headerlink" title="*语句*"></a><em><strong>*语句*</strong></em></h1><h2 id="行"><a href="#行" class="headerlink" title="*行*"></a><em><strong>*行*</strong></em></h2><p>物理行：程序员编写代码的行。</p>
<p>逻辑行：python解释器需要执行的指令。</p>
<p>建议一个逻辑行在一个物理行上。</p>
<p>如果一个物理行中使用多个逻辑行，需要使用分号；隔开。</p>
<p>如果逻辑行过长，可以使用隐式换行或显式换行。</p>
<p>– 隐式换行：所有括号的内容换行,称为隐式换行</p>
<p>  括号包括:  ()  []  {} 三种</p>
<p>– 显式换行：通过折行符 \ (反斜杠)换行，必须放在一行的末尾，目的是告诉解释器,下一行也是本行的语句。 </p>
<h2 id="pass-语句"><a href="#pass-语句" class="headerlink" title="*pass 语句*"></a><em><strong>*pass 语句*</strong></em></h2><pre><code> 作用:通常用来填充语法空白。
</code></pre>
<h2 id="选择-语句"><a href="#选择-语句" class="headerlink" title="*选择**语句*"></a><em><strong>*选择*</strong></em><em><strong>*语句*</strong></em></h2><h3 id="If-elif-else-语句"><a href="#If-elif-else-语句" class="headerlink" title="*If* *elif* *else* *语句*"></a><em><strong>*If*</strong></em> <em><strong>*elif*</strong></em> <em><strong>*else*</strong></em> <em><strong>*语句*</strong></em></h3><p>作用:</p>
<p>  让程序根据条件选择性的执行语句。</p>
<p> 语法:</p>
<p>  if 条件1:</p>
<p>​    语句块1</p>
<p>  elif 条件2:</p>
<p>​    语句块2</p>
<p>  else:</p>
<p>​    语句块3</p>
<p> 说明:</p>
<p>  elif 子句可以有0个或多个。</p>
<p>  else 子句可以有0个或1个,且只能放在if语句的最后。</p>
<p>“””</p>
<p>  条件表达式</p>
<p>“””</p>
<p># sex &#x3D; None</p>
<p># if input(“请输入性别:”) &#x3D;&#x3D; “男”:</p>
<p>#   sex &#x3D; 0</p>
<p># else:</p>
<p>#   sex &#x3D; 1</p>
<p>sex &#x3D; 0 if input(“请输入性别:”) &#x3D;&#x3D; “男” else 1</p>
<p>print(sex)</p>
<p># 满足条件赋值0 否则赋值 1</p>
<h3 id="if-语句的真值表达式"><a href="#if-语句的真值表达式" class="headerlink" title="*if 语句的真值表达式*"></a><em><strong>*if 语句的真值表达式*</strong></em></h3><p>  if 100:</p>
<p>​    print(“真值”)</p>
<p>  等同于</p>
<p>  if bool(100):</p>
<p>​    print(“真值”)</p>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="*条件表达式*"></a><em><strong>*条件表达式*</strong></em></h3><p> 语法:</p>
<p>  结果1 if 条件 else 结果2</p>
<p> 作用:</p>
<p>根据条件(True&#x2F;False) 来决定返回结果1还是结果2。</p>
<h2 id="循环-语句"><a href="#循环-语句" class="headerlink" title="*循环**语句*"></a><em><strong>*循环*</strong></em><em><strong>*语句*</strong></em></h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="*while语句*"></a><em><strong>*while语句*</strong></em></h3><p> 作用: 可以让一段代码满足条件，重复执行。</p>
<p> 语法:</p>
<p>  while 条件:</p>
<p>​    满足条件执行的语句</p>
<p>  else:</p>
<p>​    不满足条件执行的语句</p>
<p> 说明:</p>
<p>  else子句可以省略。</p>
<p>在循环体内用break终止循环时,else子句不执行。</p>
<p>“””</p>
<p>  循环语句</p>
<p>​    – while</p>
<p>“””</p>
<p># while 条件:</p>
<p>#   执行代码</p>
<p>#   if 退出条件1:</p>
<p>#     break</p>
<p># 死循环:条件永远满足的循环</p>
<p>while True:</p>
<p>  str_usd &#x3D; input(“请输入美元”)</p>
<p>  float_usd &#x3D; float(str_usd)</p>
<p>  rmb &#x3D; float_usd * 6.708</p>
<p>  print(rmb)</p>
<p>  if input(“按e键则退出”) &#x3D;&#x3D;”e”:</p>
<p>​    break # 退出循环体</p>
<p>print(“…..”)</p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="*for 语句*"></a><em><strong>*for 语句*</strong></em></h3><p> 作用:</p>
<p>  用来遍历可迭代对象的数据元素。</p>
<p>可迭代对象是指能依次获取数据元素的对象，例如：容器类型。</p>
<p> 语法:</p>
<p>  for 变量列表 in 可迭代对象:</p>
<p>​    语句块1</p>
<p>  else:</p>
<p>​    语句块2</p>
<p> 说明:</p>
<p>  else子句可以省略。</p>
<p>  在循环体内用break终止循环时,else子句不执行。</p>
<h3 id="range-函数"><a href="#range-函数" class="headerlink" title="*range 函数*"></a><em><strong>*range 函数*</strong></em></h3><p>作用:</p>
<pre><code>      用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)。
</code></pre>
<p>语法:</p>
<pre><code>      range(开始点，结束点，间隔)
  
  说明:
</code></pre>
<p>– 此函数返回的可迭代对象可以用for取出其中的元素</p>
<p>– 返回的数字不包含结束点。</p>
<p>– 开始点默认为0</p>
<p>– 间隔默认值为1 </p>
<p>“””</p>
<p>  循环语句</p>
<p>​    – for</p>
<p>“””</p>
<p># for 变量名 in 可迭代对象:</p>
<p>#   语句</p>
<p># for element in “我爱Python”:</p>
<p>#   print(element)</p>
<p># range()函数:整数生成器</p>
<p># 熟练正叙  倒叙  跳着 生成数字</p>
<p># for element in range(1,5,1): # 1  2  3  4</p>
<p>#   print(element)</p>
<p># range(1,6,2): # 1  3  5</p>
<p># range(3): #0  1  2</p>
<p># range(5,-1,-1): #5  4  3  2  1  0</p>
<p># 结论:for比while,更适合做预定次数的循环.</p>
<p>count &#x3D; 0</p>
<p>while count &lt; 3:</p>
<p>  print(count)</p>
<p>  count+&#x3D;1</p>
<p>for i in range(3):</p>
<p>  print(i)</p>
<h2 id="跳转-语句"><a href="#跳转-语句" class="headerlink" title="*跳转**语句*"></a><em><strong>*跳转*</strong></em><em><strong>*语句*</strong></em></h2><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="*break 语句*"></a><em><strong>*break 语句*</strong></em></h3><p>作用:</p>
<p>\1. 跳出循环体，后面的代码不再执行。</p>
<p>\2. 可以让while语句的else部分不执行。</p>
<h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="*continue 语句*"></a><em><strong>*continue 语句*</strong></em></h3><pre><code> 作用: 跳过本次，继续下次循环。
</code></pre>
<h1 id="容器-类型"><a href="#容器-类型" class="headerlink" title="*容器**类型*"></a><em><strong>*容器*</strong></em><em><strong>*类型*</strong></em></h1><h2 id="通用操作"><a href="#通用操作" class="headerlink" title="*通用操作*"></a><em><strong>*通用操作*</strong></em></h2><h3 id="数学运算符"><a href="#数学运算符" class="headerlink" title="*数学运算符*"></a><em><strong>*数学运算符*</strong></em></h3><p>+：用于拼接两个容器</p>
<p>+&#x3D;：用原容器与右侧容器拼接,并重新绑定变量</p>
<p>*：重复生成容器元素</p>
<p>*&#x3D;：用原容器生成重复元素, 并重新绑定变量</p>
<p>&lt; &lt;&#x3D; &gt; &gt;&#x3D; &#x3D;&#x3D; !&#x3D;：依次比较两个容器中元素,一但不同则返回比较结果。 </p>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="*成员运算符*"></a><em><strong>*成员运算符*</strong></em></h3><p>语法：</p>
<p>​	 数据 in 序列</p>
<p>数据 not in 序列</p>
<p>作用：</p>
<p>​	 如果在指定的序列中找到值，返回bool类型。</p>
<h3 id="索引-index"><a href="#索引-index" class="headerlink" title="*索引**index*"></a><em><strong>*索引*</strong></em><em><strong>*index*</strong></em></h3><p>\1. 作用：访问容器元素</p>
<p>\2. 语法：容器[整数]</p>
<p>\3. 说明：</p>
<p>正向索引从0开始，第二个索引为1，最后一个为len(s)-1</p>
<p>反向索引是从-1开始,-1代表最后一个,-2代表倒数第二个,以此类推。第一个是-len(s)</p>
<h3 id="切片slice"><a href="#切片slice" class="headerlink" title="*切片slice*"></a><em><strong>*切片slice*</strong></em></h3><p>\1. 作用：从容器中取出相应的元素重新组成一个容器。</p>
<p>\2. 语法：容器[(开始索引):(结束索引)(:(步长))]</p>
<p>小括号()括起的部分代表可省略</p>
<p>\3. 说明：</p>
<p>结束索引不包含该位置元素</p>
<p>步长是切片每次获取完当前元素后移动的偏移量</p>
<h3 id="内建-函数"><a href="#内建-函数" class="headerlink" title="*内建**函数*"></a><em><strong>*内建*</strong></em><em><strong>*函数*</strong></em></h3><p>  len(x)  返回序列的长度</p>
<p>  max(x)  返回序列的最大值元素</p>
<p>  min(x)  返回序列的最小值元素</p>
<p>  sum(x)  返回序列中所有元素的和(元素必须是数值类型)</p>
<h2 id="字符串-str"><a href="#字符串-str" class="headerlink" title="*字符串 str*"></a><em><strong>*字符串 str*</strong></em></h2><h3 id="定义"><a href="#定义" class="headerlink" title="*定义*"></a><em><strong>*定义*</strong></em></h3><p>由一系列字符组成的不可变序列容器，存储的是字符的编码值。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="*编码*"></a><em><strong>*编码*</strong></em></h3><p>字节byte：计算机最小存储单位，等于8 位bit.</p>
<p>字符：单个的数字，文字与符号。</p>
<p>字符集(码表)：存储字符与二进制序列的对应关系。</p>
<p>编码：将字符转换为对应的二进制序列的过程。</p>
<p>解码：将二进制序列转换为对应的字符的过程。</p>
<p>编码方式：</p>
<p>  \1. ASCII编码：包含英文、数字等字符，每个字符1个字节。</p>
<p>  \2. GBK编码：兼容ASCII编码，包含21003个中文；英文1个字节，汉字2个字节。</p>
<p>  \3. Unicode字符集：国际统一编码，旧字符集每个字符2字节，新字符集每个字符4字节。</p>
<p>  \4. UTF-8编码：Unicode的存储与传输方式，英文1字节，中文3字节。<img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85CE.tmp.png" alt="img"></p>
<h4 id="name-x3D-“悟空”"><a href="#name-x3D-“悟空”" class="headerlink" title="*name &#x3D; “悟空”*"></a><em><strong>*name &#x3D; “悟空”*</strong></em></h4><h4 id="name-x3D-“孙悟空”"><a href="#name-x3D-“孙悟空”" class="headerlink" title="*name &#x3D; “孙悟空”*"></a><em><strong>*name &#x3D; “孙悟空”*</strong></em></h4><h4 id="print-name-不是将字符串”悟空”-改变为”孙悟空”"><a href="#print-name-不是将字符串”悟空”-改变为”孙悟空”" class="headerlink" title="*print(name) # 不是将字符串”悟空” 改变为”孙悟空”*"></a><em><strong>*print(name) # 不是将字符串”悟空” 改变为”孙悟空”*</strong></em></h4><h4 id="而是创建了新字符串对象”孙悟空”-替换变量name中存储的地址"><a href="#而是创建了新字符串对象”孙悟空”-替换变量name中存储的地址" class="headerlink" title="*#而是创建了新字符串对象”孙悟空”,替换变量name中存储的地址*"></a><em><strong>*#而是创建了新字符串对象”孙悟空”,替换变量name中存储的地址*</strong></em><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85CF.tmp.jpg" alt="img"></h4><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="*相关函数*"></a><em><strong>*相关函数*</strong></em></h4><h4 id="b-in-整数-将整数-转换为二进制字符串"><a href="#b-in-整数-将整数-转换为二进制字符串" class="headerlink" title="*b**in(整数)* *:**将整数**转换为二进制字符串*"></a><em><strong>*b*</strong></em><em><strong>*in(整数)*</strong></em> <em><strong>*:*</strong></em><em><strong>*将整数*</strong></em><em><strong>*转换为二进制字符串*</strong></em></h4><h4 id="ord-字符串-返回该-字符串-的U-nicode-码"><a href="#ord-字符串-返回该-字符串-的U-nicode-码" class="headerlink" title="*ord(**字符串):返回该**字符串**的U**nicode**码*"></a><em><strong>*ord(*</strong></em><em><strong>*字符串):返回该*</strong></em><em><strong>*字符串*</strong></em><em><strong>*的U*</strong></em><em><strong>*nicode*</strong></em><em><strong>*码*</strong></em></h4><p>​	chr(整数):返回该整数对应的字符串</p>
<p># 字符 –&gt;  编码值</p>
<p>print(ord(“天”))</p>
<p># 编码值 –&gt; 字符</p>
<p>print(chr(97))</p>
<h3 id="字面值"><a href="#字面值" class="headerlink" title="*字面值*"></a><em><strong>*字面值*</strong></em></h3><h4 id="单引和双引号的区别"><a href="#单引和双引号的区别" class="headerlink" title="*单引和双引号的区别*"></a><em><strong>*单引和双引号的区别*</strong></em></h4><p>单引号内的双引号不算结束符</p>
<p>双引号内的单引号不算结束符</p>
<h4 id="三引号作用"><a href="#三引号作用" class="headerlink" title="*三引号作用*"></a><em><strong>*三引号作用*</strong></em></h4><p>换行会自动转换为换行符\n</p>
<p>三引号内可以包含单引号和双引号</p>
<p>作为文档字符串</p>
<p>单引号与双引号功能相同</p>
<p>str01 &#x3D; “大家好”</p>
<p>str01 &#x3D; ‘大家好’</p>
<p># 三引号:可见即所得</p>
<p>str01 &#x3D; ‘’’大</p>
<p>家</p>
<p>好</p>
<p>‘’’</p>
<p>str01 &#x3D; “””大家好”””</p>
<p>str02 &#x3D; ‘我爱”python”.’</p>
<p>str02 &#x3D; “我爱’python’.”</p>
<p>print(str02)</p>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="*转义字符*"></a><em><strong>*转义字符*</strong></em></h4><p>改变字符的原始含义。</p>
<p>\’  \”  \”””  \n  \  \t  \0 空字符 </p>
<p>原始字符串：取消转义。</p>
<p>​	a &#x3D; r”C:\newfile\test.py”</p>
<p>转义符:改变原始含义的特殊字符</p>
<p># 如果字符串内部,需要包含多种(单&#x2F;双&#x2F;三)引号,使用转义符.</p>
<p>str03 &#x3D; “我爱&quot;p’yt&quot;&quot;&quot;hon&quot;“</p>
<p>print(str03)</p>
<p># \n 换行</p>
<p>str04 &#x3D; “大家好,\n我是QTX.”</p>
<p>print(str04)</p>
<p># \t 水平制表格 tab 键</p>
<p>str04 &#x3D; “大家好,\t我是QTX.”</p>
<p>print(str04)</p>
<p>str04 &#x3D; “C:\arogram Files\breative\chareDLL\dADI”</p>
<p>print(str04)</p>
<h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="*字符串格式化*"></a><em><strong>*字符串格式化*</strong></em></h4><p>\1. 定义：生成一定格式的字符串。</p>
<p>\2. 语法：字符串%(变量)</p>
<p>“我的名字是%s,年龄是%s” % (name, age)</p>
<p>\3. 类型码：%s 字符串   %d整数   %f 浮点数</p>
<p>\4. 格式：%[- + 0 宽度.精度]类型码</p>
<p> -  : 左对齐(默认是右对齐)</p>
<p> +  : 显示正号</p>
<p> 0  : 左侧空白位置补零</p>
<p> 宽度 : 整个数据输出的宽度</p>
<p> 精度 : 保留小数点后多少位</p>
<p># 格式化字符串</p>
<p>name &#x3D; “qtx”</p>
<p>age &#x3D; 32</p>
<p># 字符串拼接,如果格式复杂,代码可读性比较差.</p>
<p>msg01 &#x3D; “我的名字是:” + name + “,年龄是:” + str(age) + “.”</p>
<p>#</p>
<p>msg02 &#x3D; “我的名字是:%s,年龄是:%d.” % (name, age)</p>
<p>print(msg01)</p>
<p>print(msg02)</p>
<p># 宽度是5  右对齐</p>
<p>str05 &#x3D; “整数是:%5d.”%(32) #整数是:  32.</p>
<p># 宽度是5  左对齐</p>
<p>str05 &#x3D; “整数是:%-5d.”%(32) #整数是:32  .</p>
<p># 宽度是2  不足2位使用0填充</p>
<p>str05 &#x3D; “时间:%02d.”%(2) #时间:02.</p>
<p># 02:00  01:59   01:09</p>
<p>str05 &#x3D; “小数:%.2f,”%(1.23556) #小数:1.23.</p>
<p># round(1.234,2)  是改变数值</p>
<p>num &#x3D; 1.234</p>
<p>num &#x3D; round(num,2)</p>
<p>print(str05)</p>
<h2 id="列表-list"><a href="#列表-list" class="headerlink" title="*列表 list*"></a><em><strong>*列表 list*</strong></em></h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="*定义*"></a><em><strong>*定义*</strong></em><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85D0.tmp.png" alt="img"><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85D1.tmp.png" alt="img"></h3><p>由一系列变量组成的可变序列容器。<img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85D2.tmp.png" alt="img"><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85D3.tmp.png" alt="img"><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85E4.tmp.png" alt="img"></p>
<h3 id="基础操作"><a href="#基础操作" class="headerlink" title="*基础操作*"></a><em><strong>*基础操作*</strong></em></h3><p>创建列表：[] list(可迭代对象)</p>
<p>添加元素：insert</p>
<p>获取元素：索引</p>
<p>删除元素：remove</p>
<h3 id="深拷贝-和浅拷贝"><a href="#深拷贝-和浅拷贝" class="headerlink" title="*深拷贝**和浅拷贝*"></a><em><strong>*深拷贝*</strong></em><em><strong>*和浅拷贝*</strong></em></h3><p>浅拷贝：是在复制过程中,只复制一层变量,不会复制深层变量绑定的对象的复制过程。</p>
<p>深拷贝：复制整个依懒的变量。</p>
<h3 id="列表V-S-字符串"><a href="#列表V-S-字符串" class="headerlink" title="*列表V**S**字符串*"></a><em><strong>*列表V*</strong></em><em><strong>*S*</strong></em><em><strong>*字符串*</strong></em></h3><p> \1. 列表和字符串都是序列,元素之间有先后顺序关系。</p>
<p> \2. 字符串是不可变的序列,列表是可变的序列。</p>
<p> \3. 字符串中每个元素只能存储字符,而列表可以存储任意类型。</p>
<p> \4. 列表和字符串都是可迭代对象。</p>
<pre><code> 5. 函数：
</code></pre>
<p>将多个字符串拼接为一个。</p>
<p>result &#x3D; “连接符”.join(列表)</p>
<p>将一个字符串拆分为多个。</p>
<p>列表 &#x3D; “a-b-c-d”.split(“分隔符”)</p>
<h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="*列表推导式*"></a><em><strong>*列表推导式*</strong></em></h3><p>\1. 定义：使用简易方法，将可迭代对象转换为列表。</p>
<p>\2. 语法：</p>
<p>变量 &#x3D; [表达式 for 变量 in 可迭代对象]</p>
<p>变量 &#x3D; [表达式 for 变量 in 可迭代对象 if 条件]</p>
<p>\3. 说明:如果if真值表达式的布尔值为False,则可迭代对象生成的数据将被丢弃。</p>
<p>list01 &#x3D; [3,5,6,7,9]</p>
<p># 需求：创建新列表，每个元素是list01中的元素的平方</p>
<p>list02 &#x3D; []</p>
<p>for item in list01:</p>
<p>  list02.append(item ** 2)</p>
<p>print(list02)</p>
<p># 语法：[对变量的操作　for 变量名　in 可迭代对象]</p>
<p>list03 &#x3D; [item ** 2 for item in list01]</p>
<p>list01 &#x3D; [3,5,6,7,9]</p>
<p># 需求：创建新列表，如果元素是偶数，则将每个元素的元素的平方存入新列表</p>
<p>list02 &#x3D; []</p>
<p>for item in list01:</p>
<p>  if item % 2 &#x3D;&#x3D; 0:</p>
<p>​    list02.append(item ** 2)</p>
<p>list03 &#x3D; [item ** 2 for item in list01 if item % 2 &#x3D;&#x3D; 0]</p>
<p>print(list03)</p>
<h3 id="列表推导式嵌套"><a href="#列表推导式嵌套" class="headerlink" title="*列表推导式嵌套*"></a><em><strong>*列表推导式嵌套*</strong></em></h3><p>\1. 传统写法：</p>
<p>result &#x3D; []</p>
<p>for r in  [“a”, “b”, “c”]:</p>
<p>  for c in [“A”, “B”, “C”]:</p>
<p>​    result.append(r + c)</p>
<p>\2. 推导式写法：</p>
<p>result &#x3D; [r + c for r in list01 for c in list02]</p>
<p>\3. 语法：</p>
<p>[表达式 for 变量1 in 可迭代对象1 for 变量2 in可迭代对象2]</p>
<h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="*元组* *tuple*"></a><em><strong>*元组*</strong></em> <em><strong>*tuple*</strong></em></h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="*定义*"></a><em><strong>*定义*</strong></em><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85E5.tmp.png" alt="img"></h3><p>由一系列变量组成的不可变序列容器。 </p>
<p>  不可变是指一但创建，不可以再添加&#x2F;删除&#x2F;修改元素。  </p>
<h3 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="*基础操作*"></a><em><strong>*基础操作*</strong></em></h3><p>创建空元组：() tuple()</p>
<p>创建非空元组 t &#x3D; (20,)</p>
<p>  t &#x3D; (1, 2, 3)</p>
<p>  t &#x3D; 100,200,300</p>
<p>tuple(可迭代对象)</p>
<p>获取元素：索引</p>
<p># 1. 创建空元组</p>
<p>t01 &#x3D; ()</p>
<p>t02 &#x3D; tuple()</p>
<p># 2. 创建具有默认值的元组</p>
<p>t01 &#x3D; (1,2,3)</p>
<p>t01 &#x3D; tuple(“abcd”)</p>
<p>t01 &#x3D; (1,2,[4,5])</p>
<p>print(t01)</p>
<p># 修改</p>
<p># t01[2] &#x3D; 100  元组元素不能修改</p>
<p>t01[2][0] &#x3D; 100 # 修改的是元素第三个元素(列表)的元素．</p>
<p># 3. 获取元素(索引　／　切片)</p>
<p>print(t01[:2])</p>
<p># 获取元组所有元素</p>
<p>for item in t01:</p>
<p>  print(item)</p>
<p># 倒序获取元组所有元素</p>
<p>for i in range(len(t01)-1, -1,-1):</p>
<p>  print(t01[i])</p>
<p>t02 &#x3D; (“a”,”b”)</p>
<p>l02 &#x3D; [“a”,”b”]</p>
<p>t03 &#x3D; t02</p>
<p>l03 &#x3D; l02</p>
<p>t02 +&#x3D; (“c”,”d”) # 创建了新元组对象，改变了t02存储的地址．</p>
<p>l02 +&#x3D; [“c”,”d”] # 将[“c”,”d”]追加到原列表中．</p>
<p>print(t02) # (‘a’, ‘b’, ‘c’, ‘d’)</p>
<p>print(t03) # (‘a’, ‘b’)</p>
<p>print(l03) # [‘a’, ‘b’, ‘c’, ‘d’]</p>
<p># 如果元组只有一个元素，必须多写一个逗号，否则视为普通对象，不是元组对象．</p>
<p>t04 &#x3D; (1,)</p>
<p>print(t04)</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="*作用*"></a><em><strong>*作用*</strong></em></h3><p>元组与列表都可以存储一系列变量，由于列表会预留内存空间，所以可以增加元素。</p>
<p>元组会按需分配内存，所以如果变量数量固定，建议使用元组，因为通常占用空间更小。</p>
<p>应用：</p>
<p>变量交换的本质就是创建元组：x, y &#x3D; y, x </p>
<p>格式化字符串的本质就是创建元祖：”姓名:%s, 年龄:%d”  % (“tarena”, 15)</p>
<h2 id="字典-dict"><a href="#字典-dict" class="headerlink" title="*字典* *dict*"></a><em><strong>*字典*</strong></em> <em><strong>*dict*</strong></em></h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="*定义*"></a><em><strong>*定义*</strong></em><img src="https://gitee.com/lichaikui/picture/raw/master/tupian/wps85E6.tmp.png" alt="img"></h3><p>由一系列键值对组成的可变映射容器。</p>
<p>映射：通过键获取值(字符串&#x2F;列表&#x2F;元组通过索引)，每条记录无序。</p>
<p>键必须惟一且不可变(字符串&#x2F;数字&#x2F;元组)，值没有限制。</p>
<h3 id="基础操作-2"><a href="#基础操作-2" class="headerlink" title="*基础操作*"></a><em><strong>*基础操作*</strong></em></h3><p>创建字典：{键1：值1，键2：值2}   dict (可迭代对象) </p>
<p>添加&#x2F;修改元素：</p>
<p>语法:</p>
<p>  字典[键] &#x3D; 数据</p>
<p>说明:</p>
<p>  键不存在,创建键,并绑定键对应的值。</p>
<p>  键存在,修改绑的绑定关系。</p>
<p>获取元素：v &#x3D; 字典[键] # 没有键则错误</p>
<p>删除元素：del 字典[键]</p>
<p># 创建空字典</p>
<p>d01 &#x3D; {}</p>
<p>d02 &#x3D; dict()</p>
<p>d01 &#x3D; {“a”:”A”,”b”:”B”}</p>
<p># d01 &#x3D; dict(“ab”) # 分不清key  value</p>
<p>d01 &#x3D; dict([(1,2),(3,4)]) # {1: 2, 3: 4}</p>
<p>#　第一次增加</p>
<p>d01[“c”] &#x3D; “C”</p>
<p>#　第二次修改</p>
<p>d01[“c”] &#x3D; “CC”</p>
<p># 读取元素(如果不存在则异常)</p>
<p># 建议：在字典中读取元素，先判断存在，在进行读取．</p>
<p>if “d” in d01:</p>
<p>  print(d01[“d”])</p>
<p>print(d01)</p>
<p># 删除</p>
<p>del d01[“c”]</p>
<p>print(d01)</p>
<p># 获取字典中所有元素：</p>
<p>for key in d01:</p>
<p>  print(key)</p>
<p>  print(d01[key])</p>
<p># 获取字典中所有记录(元组)</p>
<p>for item in d01.items():</p>
<p>  print(item[0]) # ｋｅｙ</p>
<p>  print(item[1]) # value</p>
<p>for k,v in d01.items():</p>
<p>  print(k) # ｋｅｙ</p>
<p>  print(v) # value</p>
<p># 获取所有键</p>
<p>for k in d01.keys():</p>
<p>  print(k)</p>
<p># 获取所有值</p>
<p>for v in d01.values():</p>
<p>  print(v)</p>
<h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="*字典推导式*"></a><em><strong>*字典推导式*</strong></em></h3><p>定义：使用简易方法，将可迭代对象转换为字典。</p>
<pre><code> 语法:
</code></pre>
<p>{键:值 for 变量 in 可迭代对象}</p>
<p>​     {键:值 for 变量 in 可迭代对象 if 条件}</p>
<p>ｋｅｙ：数字　　　ｖａｌｕｅ：数字平方</p>
<p># dic01 &#x3D; {}</p>
<p># for item in range(1,10):</p>
<p>#   dic01[item] &#x3D; item ** 2</p>
<p>#</p>
<p># print(dic01)</p>
<p>#</p>
<p># dic01 &#x3D; {item:item ** 2 for item in range(1,10)}</p>
<p>dic01 &#x3D; {}</p>
<p>for item in range(1, 10):</p>
<p>  if item % 2 &#x3D;&#x3D; 0:</p>
<p>​    dic01[item] &#x3D; item ** 2</p>
<p>dic01 &#x3D; {item: item ** 2 for item in range(1, 10) if item % 2 &#x3D;&#x3D; 0}</p>
<p>print(dic01)</p>
<h3 id="字典-VS-列表"><a href="#字典-VS-列表" class="headerlink" title="*字典* *VS 列表*"></a><em><strong>*字典*</strong></em> <em><strong>*VS 列表*</strong></em></h3><p> \1. 都是可变容器。</p>
<p> \2. 获取元素方式不同,列表用索引,字典用键。</p>
<p> \3. 字典的插入,删除,修改的速度快于列表。</p>
<p> \4. 列表的存储是有序的,字典的存储是无序的。</p>
<h2 id="集合-set"><a href="#集合-set" class="headerlink" title="*集合* *set*"></a><em><strong>*集合*</strong></em> <em><strong>*set*</strong></em></h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="*定义*"></a><em><strong>*定义*</strong></em></h3><p>由一系列不重复的不可变类型变量组成的可变映射容器。</p>
<p>相当于只有键没有值的字典(键则是集合的数据)。</p>
<h3 id="基础操作-3"><a href="#基础操作-3" class="headerlink" title="*基础操作*"></a><em><strong>*基础操作*</strong></em></h3><p>创建空集合： set()  set(可迭代对象)</p>
<p>创建具有默认值集合：{1, 2, 3}  set(可迭代对象)</p>
<p>添加元素：add</p>
<p>删除元素：discard</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="*运算*"></a><em><strong>*运算*</strong></em></h3><p> 交集&amp;, 并集|, 补集-, 对称补集^, 子集&lt;  超集&gt;</p>
<p>&amp; 生成两个集合的交集 返回共同元素</p>
<p> s1 &#x3D; {1, 2, 3}</p>
<p> s2 &#x3D; {2, 3, 4}</p>
<p> s3 &#x3D; s1 &amp; s2  # s3 &#x3D; {2, 3}</p>
<p>| 生成两个集合的并集 返回所有不重复元素</p>
<p> s1 &#x3D; {1, 2, 3}</p>
<p> s2 &#x3D; {2, 3, 4}</p>
<p> s3 &#x3D; s1 | s2  # s3 &#x3D; {1, 2, 3, 4}</p>
<p>- 生成两个集合的补集  返回只属于其中之一的元素</p>
<p> s1 &#x3D; {1, 2, 3}</p>
<p> s2 &#x3D; {2, 3, 4}</p>
<p> s1 - s2  # {1}, 生成属于s1,但不属于s2的所有元素的集合</p>
<p>^ 生成两个集合的对称补集 返回不同的的元素</p>
<p> s1 &#x3D; {1, 2, 3}</p>
<p> s2 &#x3D; {2, 3, 4}</p>
<p> s3 &#x3D; s1 ^ s2  # {1, 4} # 等同于(s1-s2 | s2-s1)</p>
<p>&lt; 判断一个集合是另一个集合的子集</p>
<p>&gt; 判断一个集合是另一个集合的超集</p>
<p> s1 &#x3D; {1, 2, 3}</p>
<p> s2 &#x3D; {2, 3}</p>
<p> s1 &gt; s2  # True</p>
<p> s2 &lt; s1  # True</p>
<p>&#x3D;&#x3D; !&#x3D; 集合相同或不同</p>
<p> s1 &#x3D; {1, 2, 3}</p>
<p> s2 &#x3D; {3, 2, 1}</p>
<p> s1 &#x3D;&#x3D; s2  # True</p>
<p> s1 !&#x3D; s2  # False</p>
<p>&lt;&#x3D;  &gt;&#x3D; 子集或相同,超集或相同</p>
<h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="*集合推导式*"></a><em><strong>*集合推导式*</strong></em></h3><p> 定义：使用简易方法，将可迭代对象转换为集合。</p>
<pre><code>  语法:
</code></pre>
<p>{表达式 for 变量 in 可迭代对象}</p>
<p>​     {表达式 for 变量 in 可迭代对象 if 条件}</p>
<h2 id="固定集合-frozenset"><a href="#固定集合-frozenset" class="headerlink" title="*固定集合 frozenset*"></a><em><strong>*固定集合 frozenset*</strong></em></h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="*定义*"></a><em><strong>*定义*</strong></em></h3><p>不可变的集合。</p>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="*作用*"></a><em><strong>*作用*</strong></em></h4><p>固定集合可以作为字典的键,还可以作为集合的值。</p>
<h4 id="基础操作-4"><a href="#基础操作-4" class="headerlink" title="*基础操作*"></a><em><strong>*基础操作*</strong></em></h4><p> 创建固定集合：frozenset(可迭代对象)</p>
<h4 id="运算-1"><a href="#运算-1" class="headerlink" title="*运算*"></a><em><strong>*运算*</strong></em></h4><p>等同于set</p>
<h1 id="函数-function"><a href="#函数-function" class="headerlink" title="函数 function"></a>函数 function</h1><h2 id="pycharm相关设置"><a href="#pycharm相关设置" class="headerlink" title="*pycharm相关设置*"></a><em><strong>*pycharm相关设置*</strong></em></h2><p>\1. “代码自动完成”时间延时设置</p>
<p>  File -&gt; Settings  -&gt; Editor -&gt; General -&gt; Code Completion</p>
<p>  -&gt; Autopopup in (ms):0</p>
<p>\2. 快捷键：</p>
<p>Ctrl + P  参数信息（在方法中调用参数）</p>
<p>Ctrl + Q  快速查看文档</p>
<p>Ctrl + Alt + M提取方法</p>
<h2 id="定义-6"><a href="#定义-6" class="headerlink" title="*定义*"></a><em><strong>*定义*</strong></em></h2><p>用于封装一个特定的功能，表示一个功能或者行为。</p>
<p>函数是可以重复执行的语句块, 可以重复调用。</p>
<h2 id="作用-2"><a href="#作用-2" class="headerlink" title="*作用*"></a><em><strong>*作用*</strong></em></h2><p>提高代码的可重用性和可维护性（代码层次结构更清晰）。</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="*定义函数*"></a><em><strong>*定义函数*</strong></em></h2><p>\1. 语法：</p>
<p>def 函数名(形式参数):</p>
<p>   函数体</p>
<p>\2. 说明：</p>
<p>– def 关键字：全称是define，意为”定义”。</p>
<p>– 函数名：对函数体中语句的描述，规则与变量名相同。</p>
<p>– 形式参数：方法定义者要求调用者提供的信息。</p>
<p>– 函数体：完成该功能的语句。</p>
<p>\3. 函数的第一行语句可以选择性地使用文档字符串存放函数与参数的说明。</p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="*调用函数*"></a><em><strong>*调用函数*</strong></em></h2><p>\1. 语法：函数名(实际参数) </p>
<p>\2. 说明：根据形参传递内容。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="*返回值*"></a><em><strong>*返回值*</strong></em></h2><p>\1. 定义：方法定义者告诉调用者的结果。</p>
<p>\2. 语法：return [表达式] </p>
<p>\3. 说明：</p>
<p>– 表达式就是需要返回的结果。</p>
<p>– 不带表达式的return相当于返回 None。</p>
<p>– 不带return语句，函数执行完后返回None</p>
<p>(相当于在最后加了一条return None语句)</p>
<h2 id="可变／不可变类型在传参时的区别"><a href="#可变／不可变类型在传参时的区别" class="headerlink" title="可变／不可变类型在传参时的区别"></a>可变／不可变类型在传参时的区别</h2><p>\1. 不可变类型参数有:</p>
<p>数值型(整数，浮点数,复数)</p>
<p>布尔值bool</p>
<p>None 空值</p>
<p>字符串str</p>
<p>元组tuple</p>
<p>固定集合frozenset</p>
<p>\2. 可变类型参数有:</p>
<p>列表 list</p>
<p>字典 dict</p>
<p>集合 set</p>
<p>字节数组 bytearray</p>
<p>\3. 传参说明：</p>
<p>不可变类型的数据传参时，函数内部不会改变原数据的值。</p>
<p>可变类型的数据传参时，函数内部可以改变原数据。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="*函数参数*"></a><em><strong>*函数参数*</strong></em></h2><h3 id="实参传递方式-argument"><a href="#实参传递方式-argument" class="headerlink" title="*实参传递方式**argument*"></a><em><strong>*实参传递方式*</strong></em><em><strong>*argument*</strong></em></h3><h4 id="位置传参"><a href="#位置传参" class="headerlink" title="*位置传参*"></a><em><strong>*位置传参*</strong></em></h4><p>定义：实参与形参的位置依次对应。</p>
<h5 id="序列传参"><a href="#序列传参" class="headerlink" title="*序列传参*"></a><em><strong>*序列传参*</strong></em></h5><p>定义：实参用*将序列拆解后与形参的位置依次对应。</p>
<h4 id="关键字传参"><a href="#关键字传参" class="headerlink" title="*关键字传参*"></a><em><strong>*关键字传参*</strong></em></h4><p>定义：实参根据形参的名字进行对应。</p>
<h5 id="字典关键字传参"><a href="#字典关键字传参" class="headerlink" title="*字典关键字传参*"></a><em><strong>*字典关键字传参*</strong></em></h5><p>\1. 定义：实参用**将字典拆解后与形参的名字进行对应。</p>
<p>\2. 作用：配合形参的缺省参数，可以使调用者随意传参。</p>
<h3 id="形参定义方式-parameter"><a href="#形参定义方式-parameter" class="headerlink" title="*形参定义方式**parameter*"></a><em><strong>*形参定义方式*</strong></em><em><strong>*parameter*</strong></em></h3><h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="*缺省参数*"></a><em><strong>*缺省参数*</strong></em></h4><p>\1. 语法：</p>
<p>def 函数名(形参名1&#x3D;默认实参1, 形参名2&#x3D;默认实参2, …):</p>
<p>  函数体</p>
<p>\2. 说明：</p>
<p>– 缺省参数必须自右至左依次存在，如果一个参数有缺省参数，则其右侧的所有参数都必须有缺省参数。</p>
<p>– 缺省参数可以有0个或多个，甚至全部都有缺省参数。</p>
<h4 id="位置形参"><a href="#位置形参" class="headerlink" title="*位置形参*"></a><em><strong>*位置形参*</strong></em></h4><p>\1. 语法：</p>
<p>def 函数名(形参名1, 形参名2, …):</p>
<p>函数体</p>
<h5 id="星号元组形参"><a href="#星号元组形参" class="headerlink" title="*星号元组形参*"></a><em><strong>*星号元组形参*</strong></em></h5><p>\1. 语法：</p>
<p>def 函数名(*元组形参名):</p>
<p> 函数体</p>
<p>\2. 作用：收集多余的位置传参。</p>
<p>\3. 说明：</p>
<p>– 一般命名为’args’</p>
<p>– 形参列表中最多只能有一个</p>
<h4 id="命名关键字形参"><a href="#命名关键字形参" class="headerlink" title="*命名关键字形参*"></a><em><strong>*命名关键字形参*</strong></em></h4><p>\1. 语法：</p>
<p>def 函数名(*, 命名关键字形参1, 命名关键字形参2, …):</p>
<p>函数体</p>
<p>def 函数名(*args, 命名关键字形参1, 命名关键字形参2, …):<br>           函数体</p>
<p>\2. 作用：强制实参使用关键字传参</p>
<h5 id="双星号字典形参"><a href="#双星号字典形参" class="headerlink" title="*双星号字典形参*"></a><em><strong>*双星号字典形参*</strong></em></h5><p>\1. 语法：</p>
<p>def 函数名(**字典形参名):</p>
<p>  函数体</p>
<p>\2. 作用：收集多余的关键字传参</p>
<p>\3. 说明:</p>
<p>– 一般命名为’kwargs’</p>
<p>– 形参列表中最多只能有一个</p>
<h4 id="参数自左至右的顺序"><a href="#参数自左至右的顺序" class="headerlink" title="*参数自左至右的顺序*"></a><em><strong>*参数自左至右的顺序*</strong></em></h4><p>位置形参 –&gt; 星号元组形参 –&gt; 命名关键字形参 –&gt; 双星号字典形参</p>
<h1 id="作用域LEGB"><a href="#作用域LEGB" class="headerlink" title="*作用域LEGB*"></a><em><strong>*作用域LEGB*</strong></em></h1><p>\1. 作用域：变量起作用的范围。</p>
<p>\2. Local局部作用域：函数内部。</p>
<p>\3. Enclosing  外部嵌套作用域 ：函数嵌套。 </p>
<p>\4. Global全局作用域：模块(.py文件)内部。 </p>
<p>\5. Builtin内置模块作用域：builtins.py文件。</p>
<h2 id="变量名的查找规则"><a href="#变量名的查找规则" class="headerlink" title="*变量名的查找规则*"></a><em><strong>*变量名的查找规则*</strong></em></h2><p>由内到外：L -&gt; E -&gt; G -&gt; B</p>
<p>在访问变量时，先查找本地变量，然后是包裹此函数外部的函数内部的变量，之后是全局变量，最后是内置变量。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="*局部变量*"></a><em><strong>*局部变量*</strong></em></h2><p>定义在函数内部的变量(形参也是局部变量)</p>
<p>只能在函数内部使用</p>
<p>调用函数时才被创建，函数结束后自动销毁</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="*全局变量*"></a><em><strong>*全局变量*</strong></em></h2><p>定义在函数外部,模块内部的变量。</p>
<p>在整个模块(py文件)范围内访问（但函数内不能将其直接赋值）。</p>
<h2 id="global-语句"><a href="#global-语句" class="headerlink" title="*global 语句*"></a><em><strong>*global 语句*</strong></em></h2><p>1． 作用：</p>
<p>– 在函数内部修改全局变量。</p>
<p>– 在函数内部定义全局变量(全局声明)。</p>
<p>2． 语法</p>
<p>global 变量1, 变量2, …</p>
<p>3． 说明</p>
<p>– 在函数内直接为全局变量赋值，视为创建新的局部变量。</p>
<p>– 不能先声明局部的变量，再用global声明为全局变量。</p>
<h2 id="nonlocal-语句"><a href="#nonlocal-语句" class="headerlink" title="*nonlocal 语句*"></a><em><strong>*nonlocal 语句*</strong></em></h2><p>\1. 作用：在内层函数修改外层嵌套函数内的变量</p>
<p>\2. 语法</p>
<p>nonlocal 变量名1,变量名2, …</p>
<p>\3. 说明</p>
<p>在被嵌套的内函数中进行使用</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
